package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"os"
	"regexp"
	"sort"
	"strings"
	"text/template"
	"unicode"
)

const usage = `milgen - MIL-STD-2525C Function ID Generator

Usage:
  milgen -input <markdown-file> -output <go-file> -package <package-name>

Flags:
`

// HierarchyEntry represents a symbol hierarchy entry
type HierarchyEntry struct {
	Hierarchy   string
	FuncName    string
	SIDC        string
	Description string
}

// TemplateData holds data for the Go template
type TemplateData struct {
	Package string
	Entries []HierarchyEntry
	Count   int
}

var functionTemplate = `// Code generated by milgen. DO NOT EDIT.
// Source: {{.Package}}/cmd/milgen

package {{.Package}}

const (
{{range .Entries}}	Function{{.FuncName}} string = "{{.SIDC}}" // {{.Description}}
{{end}})
`

func main() {
	var (
		inputFile   = flag.String("input", "", "Input markdown file (MIL-STD-2525C Appendix A)")
		outputFile  = flag.String("output", "", "Output Go file")
		packageName = flag.String("package", "milstd2525c", "Go package name")
		help        = flag.Bool("help", false, "Show help")
	)

	flag.Usage = func() {
		fmt.Fprint(os.Stderr, usage)
		flag.PrintDefaults()
	}
	flag.Parse()

	if *help {
		flag.Usage()
		return
	}

	if *inputFile == "" || *outputFile == "" {
		flag.Usage()
		os.Exit(1)
	}

	entries, err := extractHierarchy(*inputFile)
	if err != nil {
		log.Fatalf("Error extracting hierarchy: %v", err)
	}

	// Sort entries by function name for consistent output
	sort.Slice(entries, func(i, j int) bool {
		return entries[i].FuncName < entries[j].FuncName
	})

	err = generateGoFile(*outputFile, *packageName, entries)
	if err != nil {
		log.Fatalf("Error generating Go file: %v", err)
	}

	fmt.Printf("Generated %d function constants in %s\n", len(entries), *outputFile)
}

func extractHierarchy(filename string) ([]HierarchyEntry, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var entries []HierarchyEntry
	scanner := bufio.NewScanner(file)

	// Regex patterns to match hierarchy entries
	hierarchyPattern := regexp.MustCompile(`^##\s+(WAR\.[A-Z0-9.]+)`)
	// Handle both formats: "S * A * MF H- -- ** ** *" and "S*A*MFQ---*****"
	sidcPattern1 := regexp.MustCompile(`^##\s+S\s+\*\s+[A-Z]\s+\*\s+([A-Z0-9]+)\s+([A-Z0-9\-]+)\s+--\s+\*\*\s+\*\*\s+\*\s+(.*)$`)
	sidcPattern2 := regexp.MustCompile(`^##\s+S\*[A-Z]\*([A-Z0-9\-]+)\*+(.*)$`)

	var currentHierarchy string

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Check for hierarchy line (WAR.SOMETHING)
		if matches := hierarchyPattern.FindStringSubmatch(line); matches != nil {
			currentHierarchy = matches[1]
			continue
		}

		// Check for SIDC line that follows - try both patterns
		var sidc, description string
		var matched bool

		// Try pattern 1: "S * A * MF H- -- ** ** * DESCRIPTION"
		if matches := sidcPattern1.FindStringSubmatch(line); matches != nil && currentHierarchy != "" {
			functionBase := strings.TrimSpace(matches[1])
			functionSuffix := strings.TrimSpace(matches[2])
			description = strings.TrimSpace(matches[3])

			// Construct 6-character SIDC function ID
			sidc = functionBase + functionSuffix
			matched = true
		} else if matches := sidcPattern2.FindStringSubmatch(line); matches != nil && currentHierarchy != "" {
			// Try pattern 2: "S*A*MFQ---***** DESCRIPTION"
			sidcFull := strings.TrimSpace(matches[1])
			description = strings.TrimSpace(matches[2])

			// Extract the function part (remove trailing asterisks/dashes)
			sidc = strings.TrimRight(sidcFull, "*-")
			matched = true
		}

		if matched && currentHierarchy != "" {
			// Pad or truncate SIDC to 6 characters
			if len(sidc) < 6 {
				sidc = sidc + strings.Repeat("-", 6-len(sidc))
			} else if len(sidc) > 6 {
				sidc = sidc[:6]
			}

			// Convert hierarchy to Go function name
			funcName := hierarchyToGoFuncName(currentHierarchy)

			// Skip empty function names
			if funcName == "" {
				currentHierarchy = ""
				continue
			}

			entry := HierarchyEntry{
				Hierarchy:   currentHierarchy,
				FuncName:    funcName,
				SIDC:        sidc,
				Description: description,
			}
			entries = append(entries, entry)
			currentHierarchy = "" // Reset after processing
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return entries, nil
}

// hierarchyToGoFuncName converts WAR.AIRTRK.MIL.FIXD.DRN to WarAirtrkMilFixdDrn
func hierarchyToGoFuncName(hierarchy string) string {
	// Remove WAR. prefix and split by dots
	parts := strings.Split(strings.TrimPrefix(hierarchy, "WAR."), ".")

	// Convert each part to title case
	var result strings.Builder
	for _, part := range parts {
		if part != "" {
			result.WriteString(toTitleCase(part))
		}
	}

	return result.String()
}

// toTitleCase converts a string to title case (first letter uppercase, rest lowercase)
func toTitleCase(s string) string {
	if len(s) == 0 {
		return s
	}

	runes := []rune(strings.ToLower(s))
	runes[0] = unicode.ToUpper(runes[0])
	return string(runes)
}

func generateGoFile(filename, packageName string, entries []HierarchyEntry) error {
	// Remove duplicates by SIDC
	seenSIDC := make(map[string]bool)
	uniqueEntries := []HierarchyEntry{}

	for _, entry := range entries {
		if !seenSIDC[entry.SIDC] {
			seenSIDC[entry.SIDC] = true
			uniqueEntries = append(uniqueEntries, entry)
		}
	}

	tmpl, err := template.New("functions").Parse(functionTemplate)
	if err != nil {
		return err
	}

	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	data := TemplateData{
		Package: packageName,
		Entries: uniqueEntries,
		Count:   len(uniqueEntries),
	}

	return tmpl.Execute(file, data)
}

